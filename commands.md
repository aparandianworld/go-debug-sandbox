# Go Debugging Commands Cheat Sheet

## Delve
dlv exec # execute a precompiled binary and begin a debug session

```bash
❯ dlv help exec                        
Execute a precompiled binary and begin a debug session.

This command will cause Delve to exec the binary and immediately attach to it to
begin a new debug session. Please note that if the binary was not compiled with
optimizations disabled, it may be difficult to properly debug it. Please
consider compiling debugging binaries with -gcflags="all=-N -l" on Go 1.10
or later, -gcflags="-N -l" on earlier versions of Go.

Usage:
  dlv exec <path/to/binary> [flags]

Flags:
      --continue     Continue the debugged process on start.
  -h, --help         help for exec
      --tty string   TTY to use for the target program

Global Flags:
      --accept-multiclient               Allows a headless server to accept multiple client connections via JSON-RPC or DAP.
      --allow-non-terminal-interactive   Allows interactive sessions of Delve that don't have a terminal as stdin, stdout and stderr
      --api-version int                  Selects JSON-RPC API version when headless. The only valid value is 2. Can be reset via RPCServer.SetApiVersion. See Documentation/api/json-rpc/README.md. (default 2)
      --backend string                   Backend selection (see 'dlv help backend'). (default "default")
      --check-go-version                 Exits if the version of Go in use is not compatible (too old or too new) with the version of Delve. (default true)
      --disable-aslr                     Disables address space randomization
      --headless                         Run debug server only, in headless mode. Server will accept both JSON-RPC or DAP client connections.
      --init string                      Init file, executed by the terminal client.
  -l, --listen string                    Debugging server listen address. Prefix with 'unix:' to use a unix domain socket. (default "127.0.0.1:0")
      --log                              Enable debugging server logging.
      --log-dest string                  Writes logs to the specified file or file descriptor (see 'dlv help log').
      --log-output string                Comma separated list of components that should produce debug output (see 'dlv help log')
      --only-same-user                   Only connections from the same user that started this instance of Delve are allowed to connect. (default true)
  -r, --redirect stringArray             Specifies redirect rules for target process (see 'dlv help redirect')
      --wd string                        Working directory for running the program.
```

```bash
❯ go build -gcflags="all=-N -l"
❯ dlv exec notification-system 
Type 'help' for list of commands.
(dlv) 
```

```bash
dlv exec notification-system
Type 'help' for list of commands.
(dlv) continue
Notifier type: main.EmailNotifier
Notifier type: main.SMSNotifier
Notifier type: main.SlackNotifier
Sending email from from@example.com to to@example.com
Sending SMS to 1234567890
Sending Slack message to #general
All notifications sent.
Process 42440 has exited with status 0
(dlv) 
```

dlv debug # shows compiler diagnostics 

```bash
❯ dlv debug --build-flags="-gcflags=-m"
# github.com/aparandianworld/go-debug-sandbox/notification-system/notification-system
./email_notifier.go:10:6: can inline EmailNotifier.Send
./notifier.go:11:6: can inline describe
./slack_notifier.go:9:6: can inline SlackNotifier.Send
./sms_notifier.go:9:6: can inline SMSNotifier.Send
./main.go:21:11: inlining call to describe
<autogenerated>:1: inlining call to EmailNotifier.Send
<autogenerated>:1: inlining call to SlackNotifier.Send
<autogenerated>:1: inlining call to SMSNotifier.Send
./email_notifier.go:10:7: leaking param: e
./email_notifier.go:10:29: message does not escape
./email_notifier.go:12:12: ... argument does not escape
./email_notifier.go:12:47: e.from escapes to heap
./email_notifier.go:12:55: e.to escapes to heap
./main.go:7:24: []Notifier{...} does not escape
./main.go:8:16: EmailNotifier{...} escapes to heap
./main.go:12:14: SMSNotifier{...} escapes to heap
./main.go:15:16: SlackNotifier{...} escapes to heap
./main.go:21:11: ... argument does not escape
./main.go:27:14: ... argument does not escape
./main.go:31:13: ... argument does not escape
./main.go:31:14: "All notifications sent." escapes to heap
./notifier.go:11:15: leaking param: n
./notifier.go:12:12: ... argument does not escape
./slack_notifier.go:9:7: leaking param: s
./slack_notifier.go:9:29: message does not escape
./slack_notifier.go:11:12: ... argument does not escape
./slack_notifier.go:11:47: s.channel escapes to heap
./sms_notifier.go:9:7: leaking param: s
./sms_notifier.go:9:27: message does not escape
./sms_notifier.go:11:12: ... argument does not escape
./sms_notifier.go:11:37: s.phoneNumber escapes to heap
<autogenerated>:1: ... argument does not escape
<autogenerated>:1: e.from escapes to heap
<autogenerated>:1: e.to escapes to heap
<autogenerated>:1: ... argument does not escape
<autogenerated>:1: s.channel escapes to heap
<autogenerated>:1: ... argument does not escape
<autogenerated>:1: s.phoneNumber escapes to heap
Type 'help' for list of commands.
(dlv)
(dlv) rebuild
# github.com/aparandianworld/go-debug-sandbox/notification-system/notification-system
./email_notifier.go:10:6: can inline EmailNotifier.Send
./notifier.go:11:6: can inline describe
./slack_notifier.go:9:6: can inline SlackNotifier.Send
./sms_notifier.go:9:6: can inline SMSNotifier.Send
./main.go:21:11: inlining call to describe
<autogenerated>:1: inlining call to EmailNotifier.Send
<autogenerated>:1: inlining call to SlackNotifier.Send
<autogenerated>:1: inlining call to SMSNotifier.Send
./email_notifier.go:10:7: leaking param: e
./email_notifier.go:10:29: message does not escape
./email_notifier.go:12:12: ... argument does not escape
./email_notifier.go:12:47: e.from escapes to heap
./email_notifier.go:12:55: e.to escapes to heap
./main.go:7:24: []Notifier{...} does not escape
./main.go:8:16: EmailNotifier{...} escapes to heap
./main.go:12:14: SMSNotifier{...} escapes to heap
./main.go:15:16: SlackNotifier{...} escapes to heap
./main.go:21:11: ... argument does not escape
./main.go:27:14: ... argument does not escape
./main.go:31:13: ... argument does not escape
./main.go:31:14: "All notifications sent." escapes to heap
./notifier.go:11:15: leaking param: n
./notifier.go:12:12: ... argument does not escape
./slack_notifier.go:9:7: leaking param: s
./slack_notifier.go:9:29: message does not escape
./slack_notifier.go:11:12: ... argument does not escape
./slack_notifier.go:11:47: s.channel escapes to heap
./sms_notifier.go:9:7: leaking param: s
./sms_notifier.go:9:27: message does not escape
./sms_notifier.go:11:12: ... argument does not escape
./sms_notifier.go:11:37: s.phoneNumber escapes to heap
<autogenerated>:1: ... argument does not escape
<autogenerated>:1: e.from escapes to heap
<autogenerated>:1: e.to escapes to heap
<autogenerated>:1: ... argument does not escape
<autogenerated>:1: s.channel escapes to heap
<autogenerated>:1: ... argument does not escape
<autogenerated>:1: s.phoneNumber escapes to heap
(dlv)  

```

delv attach # allows you to attach to a running process

```bash
❯ dlv attach 42440
Type 'help' for list of commands.
(dlv) 
```

delv test # allows you to debug your unit tests

```bash
❯ dlv test
Type 'help' for list of commands.
(dlv) 
```

```bash
❯ dlv test -- -test.v
Type 'help' for list of commands.
(dlv) continue
=== RUN   TestHello_With_Assert
--- PASS: TestHello_With_Assert (0.00s)
=== RUN   TestHello_Table_With_Assert
=== RUN   TestHello_Table_With_Assert/Aaron_en
=== RUN   TestHello_Table_With_Assert/Aaron_es
=== RUN   TestHello_Table_With_Assert/Aaron_fr
--- PASS: TestHello_Table_With_Assert (0.00s)
    --- PASS: TestHello_Table_With_Assert/Aaron_en (0.00s)
    --- PASS: TestHello_Table_With_Assert/Aaron_es (0.00s)
    --- PASS: TestHello_Table_With_Assert/Aaron_fr (0.00s)
=== RUN   TestHello_English
--- PASS: TestHello_English (0.00s)
=== RUN   TestHello_Spanish
--- PASS: TestHello_Spanish (0.00s)
=== RUN   TestHello_French
--- PASS: TestHello_French (0.00s)
=== RUN   TestIsEmpty
--- PASS: TestIsEmpty (0.00s)
=== RUN   TestHello_Table
=== RUN   TestHello_Table/Aaron_en
=== RUN   TestHello_Table/Aaron_es
=== RUN   TestHello_Table/Aaron_fr
--- PASS: TestHello_Table (0.00s)
    --- PASS: TestHello_Table/Aaron_en (0.00s)
    --- PASS: TestHello_Table/Aaron_es (0.00s)
    --- PASS: TestHello_Table/Aaron_fr (0.00s)
PASS
Process 58475 has exited with status 0
(dlv) 
(dlv) 
```

dlv breakpoint | step | stepout | continue | next # control execution workflow

```bash
dlv) c
> [Breakpoint 1] main.main() ./main.go:44 (hits goroutine(1):1 total:1) (PC: 0x10464de50)
    39:                 }
    40:         }
    41:         return people
    42: }
    43:
=>  44: func main() {
    45:         people := make([]*Person, 25)
    46:         people = populate(people)
    47:
    48:         fmt.Printf("People:\n")
    49:         for _, p := range people {
(dlv) n
> main.main() ./main.go:45 (PC: 0x10464de60)
    40:         }
    41:         return people
    42: }
    43:
    44: func main() {
=>  45:         people := make([]*Person, 25)
    46:         people = populate(people)
    47:
    48:         fmt.Printf("People:\n")
    49:         for _, p := range people {
    50:                 fmt.Printf("%v\n", *p)
(dlv) n
> main.main() ./main.go:46 (PC: 0x10464de98)
    41:         return people
    42: }
    43:
    44: func main() {
    45:         people := make([]*Person, 25)
=>  46:         people = populate(people)
    47:
    48:         fmt.Printf("People:\n")
    49:         for _, p := range people {
    50:                 fmt.Printf("%v\n", *p)
    51:         }
(dlv) ni
> main.main() ./main.go:46 (PC: 0x10464de9c)
Command failed: could not find watchpoint at address 0x10464de98
(dlv) n
> main.main() ./main.go:48 (PC: 0x10464deac)
    43:
    44: func main() {
    45:         people := make([]*Person, 25)
    46:         people = populate(people)
    47:
=>  48:         fmt.Printf("People:\n")
    49:         for _, p := range people {
    50:                 fmt.Printf("%v\n", *p)
    51:         }
    52:         fmt.Printf("\n")
    53:
(dlv) s
> fmt.Printf() /opt/homebrew/Cellar/go/1.25.4/libexec/src/fmt/print.go:232 (PC: 0x104647010)
   227:         return
   228: }
   229:
   230: // Printf formats according to a format specifier and writes to standard output.
   231: // It returns the number of bytes written and any write error encountered.
=> 232: func Printf(format string, a ...any) (n int, err error) {
   233:         return Fprintf(os.Stdout, format, a...)
   234: }
   235:
   236: // Sprintf formats according to a format specifier and returns the resulting string.
   237: func Sprintf(format string, a ...any) string {
(dlv) s
> fmt.Printf() /opt/homebrew/Cellar/go/1.25.4/libexec/src/fmt/print.go:233 (PC: 0x10464703c)
   228: }
   229:
   230: // Printf formats according to a format specifier and writes to standard output.
   231: // It returns the number of bytes written and any write error encountered.
   232: func Printf(format string, a ...any) (n int, err error) {
=> 233:         return Fprintf(os.Stdout, format, a...)
   234: }
   235:
   236: // Sprintf formats according to a format specifier and returns the resulting string.
   237: func Sprintf(format string, a ...any) string {
   238:         p := newPrinter()
(dlv) s
> fmt.Fprintf() /opt/homebrew/Cellar/go/1.25.4/libexec/src/fmt/print.go:222 (PC: 0x104646ef0)
   217:
   218: // These routines end in 'f' and take a format string.
   219:
   220: // Fprintf formats according to a format specifier and writes to w.
   221: // It returns the number of bytes written and any write error encountered.
=> 222: func Fprintf(w io.Writer, format string, a ...any) (n int, err error) {
   223:         p := newPrinter()
   224:         p.doPrintf(format, a)
   225:         n, err = w.Write(p.buf)
   226:         p.free()
   227:         return
(dlv) s
> fmt.Fprintf() /opt/homebrew/Cellar/go/1.25.4/libexec/src/fmt/print.go:223 (PC: 0x104646f24)
   218: // These routines end in 'f' and take a format string.
   219:
   220: // Fprintf formats according to a format specifier and writes to w.
   221: // It returns the number of bytes written and any write error encountered.
   222: func Fprintf(w io.Writer, format string, a ...any) (n int, err error) {
=> 223:         p := newPrinter()
   224:         p.doPrintf(format, a)
   225:         n, err = w.Write(p.buf)
   226:         p.free()
   227:         return
   228: }
(dlv) stepout
People:
> fmt.Printf() /opt/homebrew/Cellar/go/1.25.4/libexec/src/fmt/print.go:233 (PC: 0x10464706c)
Values returned:
        n: 8
        err: error nil

   228: }
   229:
   230: // Printf formats according to a format specifier and writes to standard output.
   231: // It returns the number of bytes written and any write error encountered.
   232: func Printf(format string, a ...any) (n int, err error) {
=> 233:         return Fprintf(os.Stdout, format, a...)
   234: }
   235:
   236: // Sprintf formats according to a format specifier and returns the resulting string.
   237: func Sprintf(format string, a ...any) string {
   238:         p := newPrinter()
(dlv) stepout
> main.main() ./main.go:49 (PC: 0x10464dec8)
Values returned:
        n: 8
        err: error nil

    44: func main() {
    45:         people := make([]*Person, 25)
    46:         people = populate(people)
    47:
    48:         fmt.Printf("People:\n")
=>  49:         for _, p := range people {
    50:                 fmt.Printf("%v\n", *p)
    51:         }
    52:         fmt.Printf("\n")
    53:
    54:         p := findPerson(people, "Sue")
(dlv) continue
{John 302 56}
{Jane 547 90}
{Bob 679 55}
{Alice 315 44}
{Tom 781 78}
{Sally 471 32}
{Mike 673 51}
{Sue 129 89}
{Bill 768 64}
{Lily 428 64}
{Aaron 220 41}
{John 538 10}
{Jane 783 11}
{Bob 68 96}
{Alice 546 92}
{Tom 840 71}
{Sally 618 10}
{Mike 549 46}
{Sue 301 55}
{Bill 108 80}
{Lily 994 39}
{Aaron 525 8}
{John 10 50}
{Jane 28 39}
{Bob 276 53}
```

dlv trace # similar to breakpoint but it traces function calls and does not stop execution

```bash
(dlv) help trace
Set tracepoint.

        trace [name] [locspec]

A tracepoint is a breakpoint that does not stop the execution of the program, instead when the tracepoint is hit a notification is displayed. See Documentation/cli/locspec.md for the syntax of locspec. If locspec is omitted a tracepoint will be set on the current line.

See also: "help on", "help cond" and "help clear"
(dlv) list
Stopped at: 0x104d689c0
=>   1: no source available
(dlv) trace main.findPerson
Tracepoint 1 set at 0x104bad84c for main.findPerson() ./main.go:15
(dlv) continue
People:
{John 641 16}
{Jane 502 85}
{Bob 543 35}
{Alice 104 27}
{Tom 341 70}
{Sally 291 74}
{Mike 750 34}
{Sue 409 9}
{Bill 604 4}
{Lily 295 60}
{Aaron 865 51}
{John 63 66}
{Jane 223 38}
{Bob 198 29}
{Alice 364 95}
{Tom 243 75}
{Sally 512 15}
{Mike 670 98}
{Sue 11 59}
{Bill 206 32}
{Lily 677 32}
{Aaron 511 20}
{John 963 42}
{Jane 778 58}
{Bob 931 63}

> goroutine(1): main.findPerson([]*main.Person len: 25, cap: 25, [...], "Sue")
>> goroutine(1): main.findPerson => ((*main.Person)(0x140000a2180))
Found: {Sue 409 9}
Process 92492 has exited with status 0
(dlv)

```